<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Game</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            color: #333;
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #ffffff;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            text-align: center;
            width: 100%;
            max-width: 600px;
        }

        h1 {
            color: #007bff;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .control-group label {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #555;
        }

        .controls select, .controls button {
            padding: 10px 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s;
        }

        .controls select {
            min-width: 120px;
        }

        .controls button {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }

        .controls button:hover {
            background-color: #0056b3;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .controls button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            border-color: #cccccc;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            font-size: 1.1em;
            font-weight: bold;
        }

        .game-info p {
            margin: 0;
            padding: 8px 12px;
            background-color: #e9ecef;
            border-radius: 6px;
        }

        .puzzle-area {
            display: flex;
            justify-content: space-around; /* Adjust as needed */
            align-items: flex-start;
            gap: 20px; /* Space between puzzle and reference */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        #puzzle-board-container {
            position: relative;
            width: clamp(280px, 70vw, 400px); /* Responsive board size */
            max-width: 400px;
            aspect-ratio: 1 / 1;
            border: 2px solid #007bff;
            border-radius: 8px;
            overflow: hidden;
            margin: 0 auto 20px auto; /* Center if it wraps alone */
        }
        
        @media (min-width: 550px) { /* Adjust breakpoint as needed */
            #puzzle-board-container {
                 margin: 0; /* Remove auto margin when side-by-side */
            }
        }


        #puzzle-board {
            display: grid;
            width: 100%;
            height: 100%;
            background-color: #ddd;
        }

        .puzzle-piece {
            border: 1px solid #fff;
            box-sizing: border-box;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, opacity 0.2s ease-in-out;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: rgba(0,0,0,0.2);
            user-select: none;
            background-size: cover; /* Set by JS */
            background-position: center; /* Set by JS */
        }

        .puzzle-piece:hover:not(.empty-piece) {
            opacity: 0.85;
            transform: scale(1.05);
            z-index: 10;
        }

        .empty-piece {
            background-image: none !important;
            background-color: #f0f2f5;
            cursor: default;
            opacity: 1 !important;
            transform: none !important;
        }
        
        .reference-image-container {
            width: clamp(100px, 25vw, 150px); /* Responsive reference image size */
            aspect-ratio: 1 / 1; /* Keep it square if desired */
            border: 1px solid #ccc;
            border-radius: 6px;
            overflow: hidden;
            margin: 0 auto 20px auto; /* Center if it wraps alone */
        }
        
        @media (min-width: 550px) { /* Adjust breakpoint as needed */
            .reference-image-container {
                 margin: 0; /* Remove auto margin when side-by-side */
            }
        }


        #referenceImage {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Or 'cover' depending on desired look */
        }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: inherit;
        }

        #win-message {
            font-size: 1.8em;
            margin-bottom: 20px;
        }

        #play-again-button {
            padding: 12px 25px;
            font-size: 1.1em;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #play-again-button:hover {
            background-color: #218838;
        }

        .instructions {
            font-size: 0.9em;
            color: #666;
            margin-top: 15px;
            line-height: 1.5;
        }

        @media (max-width: 549px) { /* Stack controls and puzzle elements vertically */
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .control-group, .controls button {
                width: 100%;
                box-sizing: border-box;
            }
            .puzzle-area {
                flex-direction: column;
                align-items: center; /* Center items when stacked */
            }
            #puzzle-board-container, .reference-image-container {
                margin: 0 auto 20px auto; /* Center when stacked */
            }
            .game-info {
                flex-direction: column;
                gap: 8px;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Sliding Puzzle</h1>

        <div class="controls">
            <div class="control-group">
                <label for="levelSelect">Level:</label>
                <select id="levelSelect">
                    <option value="3" selected>Easy (3x3)</option>
                    <option value="4">Medium (4x4)</option>
                    <option value="5">Hard (5x5)</option>
                </select>
            </div>
            <button id="startButton">Start Game</button>
            <button id="resetButton" disabled>Reset</button>
        </div>

        <div class="game-info">
            <p>Moves: <span id="moves">0</span></p>
            <p>Time: <span id="timer">00:00</span></p>
        </div>

        <div class="puzzle-area">
            <div id="puzzle-board-container">
                <div id="puzzle-board">
                    <!-- Puzzle pieces will be generated here -->
                </div>
                <div id="message-overlay">
                    <p id="win-message"></p>
                    <button id="play-again-button">Play Again</button>
                </div>
            </div>
            <div class="reference-image-container">
                <img id="referenceImage" src="" alt="Reference Puzzle">
            </div>
        </div>
        
        <!-- Hidden image element to load and get dimensions for puzzle pieces -->
        <img id="sourceImageLoader" src="" alt="Puzzle Source Loader" style="display:none;">

        <p class="instructions">
            Click "Start Game" or a tile to begin. Click a tile adjacent to the empty space to slide it.
            Arrange tiles to form the original image shown as reference.
        </p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            // IMPORTANT: Place your default image in an 'images' folder 
            // next to this HTML file and update the path below if needed.
            const DEFAULT_IMAGE_SRC = 'images/Jellyfish.jpg'; 

            // --- DOM Elements ---
            const puzzleBoard = document.getElementById('puzzle-board');
            const startButton = document.getElementById('startButton');
            const resetButton = document.getElementById('resetButton');
            const levelSelect = document.getElementById('levelSelect');
            const movesDisplay = document.getElementById('moves');
            const timerDisplay = document.getElementById('timer');
            const sourceImageLoader = document.getElementById('sourceImageLoader'); // For piece generation
            const referenceImage = document.getElementById('referenceImage'); // For display
            const messageOverlay = document.getElementById('message-overlay');
            const winMessage = document.getElementById('win-message');
            const playAgainButton = document.getElementById('play-again-button');

            // --- Game State Variables ---
            let gridSize = parseInt(levelSelect.value);
            let pieces = []; // 2D array for piece values
            let emptyCoords = { row: 0, col: 0 };
            let moves = 0;
            let timerInterval;
            let seconds = 0;
            let gameStarted = false;
            let currentImageSrc = DEFAULT_IMAGE_SRC; // Set the default image
            let startTime = 0;

            // --- Core Game Functions ---
            function initGameLoading() {
                gridSize = parseInt(levelSelect.value);
                currentImageSrc = DEFAULT_IMAGE_SRC; // Always use the default
                
                sourceImageLoader.src = currentImageSrc;
                referenceImage.src = currentImageSrc; // Set reference image immediately

                sourceImageLoader.onload = () => {
                    resetGameVisuals(); // Reset counters and visual elements
                    createPuzzleMatrix();
                    shufflePieces();
                    renderBoard();
                    if (gameStarted) { // Only start timer if game was intentionally started
                        startTimer();
                    }
                };
                sourceImageLoader.onerror = () => {
                    alert(`Error loading image: ${currentImageSrc}. 
                    Please ensure:
                    1. You have an 'images' folder in the same directory as this HTML file.
                    2. The image file '${currentImageSrc.split('/').pop()}' exists in the 'images' folder.
                    3. If you changed DEFAULT_IMAGE_SRC, ensure it's correct.`);
                    puzzleBoard.innerHTML = `<p style="color:red; padding:20px;">Failed to load puzzle image.</p>`;
                    referenceImage.alt = "Image load error";
                    referenceImage.src = ""; // Clear broken image icon
                    // Disable game start if image fails
                    startButton.disabled = true;
                    resetButton.disabled = true;
                    gameStarted = false;
                };
            }
            
            function startGameProcedure() {
                if (gameStarted) return; // Prevent multiple starts if already processing

                gameStarted = true;
                startButton.disabled = true;
                resetButton.disabled = false;
                levelSelect.disabled = true;

                seconds = 0;
                moves = 0;
                updateTimerDisplay();
                updateMovesDisplay();
                
                initGameLoading(); // This will handle image loading and then setup/shuffle/render/start timer
            }


            function resetGameVisuals() {
                moves = 0;
                seconds = 0;
                updateMovesDisplay();
                updateTimerDisplay();
                stopTimer();
                puzzleBoard.innerHTML = '';
                puzzleBoard.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                puzzleBoard.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
                messageOverlay.style.display = 'none';
            }

            function fullResetAndEnableControls() {
                resetGameVisuals();
                gameStarted = false; // Crucial for allowing a new start
                startButton.disabled = false;
                resetButton.disabled = true;
                levelSelect.disabled = false;
                initGameLoading(); // Load default state, but don't auto-start timer
            }

            function createPuzzleMatrix() {
                pieces = [];
                let count = 1;
                for (let i = 0; i < gridSize; i++) {
                    pieces[i] = [];
                    for (let j = 0; j < gridSize; j++) {
                        if (i === gridSize - 1 && j === gridSize - 1) {
                            pieces[i][j] = 0; // 0 represents the empty space
                            emptyCoords = { row: i, col: j };
                        } else {
                            pieces[i][j] = count++;
                        }
                    }
                }
            }

            function shufflePieces() {
                let shuffleMoves = gridSize * gridSize * 10;
                for (let i = 0; i < shuffleMoves; i++) {
                    const neighbors = getValidNeighbors(emptyCoords.row, emptyCoords.col);
                    if (neighbors.length > 0) {
                        const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                        swapPiecesInMatrix(emptyCoords.row, emptyCoords.col, randomNeighbor.row, randomNeighbor.col);
                        emptyCoords = { row: randomNeighbor.row, col: randomNeighbor.col };
                    }
                }
            }

            function getValidNeighbors(row, col) {
                const neighbors = [];
                if (row > 0) neighbors.push({ row: row - 1, col: col });
                if (row < gridSize - 1) neighbors.push({ row: row + 1, col: col });
                if (col > 0) neighbors.push({ row: row, col: col - 1 });
                if (col < gridSize - 1) neighbors.push({ row: row, col: col + 1 });
                return neighbors;
            }

            function renderBoard() {
                puzzleBoard.innerHTML = '';
                const imageWidth = sourceImageLoader.naturalWidth;
                const imageHeight = sourceImageLoader.naturalHeight;

                if (imageWidth === 0 || imageHeight === 0) {
                    console.error("Image dimensions are zero for piece rendering.");
                    // Error is handled by sourceImageLoader.onerror for main message
                    return;
                }

                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        const pieceValue = pieces[i][j];
                        const pieceDiv = document.createElement('div');
                        pieceDiv.classList.add('puzzle-piece');
                        pieceDiv.dataset.row = i;
                        pieceDiv.dataset.col = j;

                        if (pieceValue === 0) {
                            pieceDiv.classList.add('empty-piece');
                        } else {
                            const originalRow = Math.floor((pieceValue - 1) / gridSize);
                            const originalCol = (pieceValue - 1) % gridSize;
                            
                            pieceDiv.style.backgroundImage = `url(${currentImageSrc})`;
                            pieceDiv.style.backgroundSize = `${gridSize * 100}% ${gridSize * 100}%`;
                            pieceDiv.style.backgroundPosition = `-${originalCol * 100}% -${originalRow * 100}%`;
                            
                            pieceDiv.addEventListener('click', handlePieceClick);
                        }
                        puzzleBoard.appendChild(pieceDiv);
                    }
                }
            }

            function handlePieceClick(event) {
                if (!gameStarted) {
                    startGameProcedure(); // Start the game if a tile is clicked first
                    return; // The click itself doesn't count as a move yet, board will reshuffle
                }

                const clickedRow = parseInt(event.target.dataset.row);
                const clickedCol = parseInt(event.target.dataset.col);

                if (isAdjacent(clickedRow, clickedCol, emptyCoords.row, emptyCoords.col)) {
                    swapPiecesInMatrix(clickedRow, clickedCol, emptyCoords.row, emptyCoords.col);
                    emptyCoords = { row: clickedRow, col: clickedCol };
                    moves++;
                    updateMovesDisplay();
                    renderBoard(); // Re-render the board with the moved piece
                    
                    if (checkWin()) {
                        handleWin();
                    }
                }
            }

            function isAdjacent(r1, c1, r2, c2) {
                return (Math.abs(r1 - r2) === 1 && c1 === c2) || (Math.abs(c1 - c2) === 1 && r1 === r2);
            }

            function swapPiecesInMatrix(r1, c1, r2, c2) {
                const temp = pieces[r1][c1];
                pieces[r1][c1] = pieces[r2][c2];
                pieces[r2][c2] = temp;
            }

            function checkWin() {
                let count = 1;
                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        if (i === gridSize - 1 && j === gridSize - 1) {
                            if (pieces[i][j] !== 0) return false;
                        } else {
                            if (pieces[i][j] !== count++) return false;
                        }
                    }
                }
                return true;
            }

            function handleWin() {
                stopTimer();
                gameStarted = false; // Game is over
                winMessage.textContent = `You Won! Moves: ${moves}, Time: ${timerDisplay.textContent}`;
                messageOverlay.style.display = 'flex';
                resetButton.disabled = true; 
                startButton.disabled = false; 
                levelSelect.disabled = false;
            }

            // --- Timer & Moves Display ---
            function startTimer() {
                stopTimer(); 
                startTime = Date.now() - (seconds * 1000);
                timerInterval = setInterval(() => {
                    seconds = Math.floor((Date.now() - startTime) / 1000);
                    updateTimerDisplay();
                }, 1000);
            }

            function stopTimer() {
                clearInterval(timerInterval);
            }

            function updateTimerDisplay() {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
            }

            function updateMovesDisplay() {
                movesDisplay.textContent = moves;
            }

            // --- Event Listeners ---
            startButton.addEventListener('click', startGameProcedure);

            resetButton.addEventListener('click', () => {
                // Reset always re-shuffles and restarts the timer for the current level
                stopTimer(); 
                seconds = 0;
                moves = 0;
                updateTimerDisplay();
                updateMovesDisplay();
                gameStarted = true; // Ensure timer restarts
                startButton.disabled = true; // Keep start disabled as game is active
                levelSelect.disabled = true; // Keep level locked
                initGameLoading(); // Re-initialize with current settings, shuffles and starts timer
            });
            
            playAgainButton.addEventListener('click', () => {
                messageOverlay.style.display = 'none';
                fullResetAndEnableControls(); 
            });

            levelSelect.addEventListener('change', () => {
                if (!gameStarted) { // Allow level change only if game not started
                    fullResetAndEnableControls(); // This will also call initGameLoading
                }
            });

            // --- Initial Page Load ---
            fullResetAndEnableControls(); // Set up the board in its initial, non-started state
        });
    </script>
</body>
</html>
